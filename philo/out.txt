
#include "./philo.h"
int	check_end(t_desk *d)
{
	int	end;

	pthread_mutex_lock(&d->end_mutex);
	end = d->end;
	pthread_mutex_unlock(&d->end_mutex);
	return (end);
}

void	set_end(t_desk *d)
{
	pthread_mutex_lock(&d->end_mutex);
	d->end = 1;
	pthread_mutex_unlock(&d->end_mutex);
}

int	take_forks(t_philo *p)
{
	if (p->id % 2 == 0)
	{
		pthread_mutex_lock(&p->right_fork->fork);
		printf(G"%lld %d has taken a fork\n"D, current_time_in_milliseconds() - p->desk->now, p->id);
		pthread_mutex_lock(&p->left_fork->fork);
		printf(G"%lld %d has taken a fork\n"D, current_time_in_milliseconds() - p->desk->now, p->id);
	}
	else
	{
		pthread_mutex_lock(&p->left_fork->fork);
		printf(G"%lld %d has taken a fork\n"D, current_time_in_milliseconds() - p->desk->now, p->id);
		pthread_mutex_lock(&p->right_fork->fork);
		printf(G"%lld %d has taken a fork\n"D, current_time_in_milliseconds() - p->desk->now, p->id);
	}
	return (0);
}

int	eat(t_philo *p)
{
	printf(Y"%lld %d is eating\n"D, current_time_in_milliseconds() - p->desk->now, p->id);
	pthread_mutex_lock(&p->state_mutex);
	p->had_meal_time = current_time_in_milliseconds();
	pthread_mutex_unlock(&p->state_mutex);
	usleep(p->desk->eat_time * 1000);
	pthread_mutex_lock(&p->state_mutex);
	p->meals++;
	if (p->desk->meal_amount != -1 && p->meals >= p->desk->meal_amount)
		p->done = 1;
	pthread_mutex_unlock(&p->state_mutex);
	pthread_mutex_unlock(&p->right_fork->fork);
	pthread_mutex_unlock(&p->left_fork->fork);
	return (0);
}

int	sleep_and_think(t_philo *p)
{
	printf(B"%lld %d is sleeping\n"D, current_time_in_milliseconds() - p->desk->now, p->id);
	usleep(p->desk->sleep_time * 1000);
	printf(M"%lld %d is thinking\n"D, current_time_in_milliseconds() - p->desk->now, p->id);
	return (0);
}

void	*run_philosopher(void *p_point)
{
	t_philo	*p;

	p = (t_philo *)p_point;
	while (1)
	{
		if (check_end(p->desk))
			break ;
		if (p->desk->philo_amount == 1)
		{
			printf(G"%lld %d has taken a fork\n"D, current_time_in_milliseconds() - p->desk->now, p->id);
			usleep(p->desk->die_time * 1000);
			break ;
		}
		if (take_forks(p) != 0 || eat(p) != 0 || sleep_and_think(p) != 0)
			break ;
	}
	return (NULL);
}



#include "./philo.h"

int	setup_philos_and_forks(t_desk *d)
{
	int	i;

	i = 0;
	while (i < d->philo_amount)
	{
		if (pthread_mutex_init(&d->forks[i].fork, NULL) != 0)
			return (1);
		if (pthread_mutex_init(&d->philos[i].state_mutex, NULL) != 0)
			return (1);
		d->forks[i].id = i;
		d->philos[i].id = i + 1;
		d->philos[i].meals = 0;
		d->philos[i].done = 0;
		d->philos[i].had_meal_time = d->now;
		d->philos[i].desk = d;
		d->philos[i].left_fork = &d->forks[i];
		d->philos[i].right_fork = &d->forks[(i + 1) % d->philo_amount];
		i++;
	}
	return (0);
}

int	setup(t_desk *d)
{
	d->end = 0;
	d->forks = malloc(sizeof(t_fork) * d->philo_amount);
	if (!d->forks)
		return (1);
	d->philos = malloc(sizeof(t_philo) * d->philo_amount);
	if (!d->philos)
	{
		free(d->forks);
		return (1);
	}
	if (pthread_mutex_init(&d->end_mutex, NULL) != 0)
		return (1);
	setup_philos_and_forks(d);
	return (0);
}

int	end(t_desk *d)
{
	int	i;

	pthread_join(d->monitor, NULL);
	i = 0;
	while (i < d->philo_amount)
	{
		pthread_join(d->philos[i].thread, NULL);
		pthread_mutex_destroy(&d->forks[i].fork);
		pthread_mutex_destroy(&d->philos[i].state_mutex);
		i++;
	}
	pthread_mutex_destroy(&d->end_mutex);
	free(d->philos);
	free(d->forks);
	return (0);
}


#include "./philo.h"

int	ft_isdigit(int c)
{
	if ((c >= '0' && c <= '9'))
		return (1);
	return (0);
}

int	ft_isspace(char c)
{
	if (c == 32 || (c >= 9 && c <= 13))
		return (1);
	return (0);
}

long	ft_atol(const char *str)
{
	long	i;
	int		ms;

	i = 0;
	ms = 0;
	while (ft_isspace(*str))
		str++;
	if (*str == 43 || *str == 45)
	{
		if (*str == 45)
			ms++;
		str++;
	}
	if (!ft_isdigit(*str))
		return (0);
	while (*str != '\0' && ft_isdigit(*str))
	{
		i = i * 10 + (*str - '0');
		str++;
	}
	if (ms != 0)
		i = (i * (-1));
	return (i);
}

long long	current_time_in_milliseconds(void)
{
	struct timeval	now;
	long long		milliseconds;

	gettimeofday(&now, NULL);
	milliseconds = (now.tv_sec * 1000LL) + (now.tv_usec / 1000);
	return (milliseconds);
}

void	check_numeric(int *valid, char *argument)
{
	int	i;

	if (*valid == 0)
	{
		i = 0;
		while (ft_isspace(argument[i]))
			i++;
		while (argument[i] == 43)
			i++;
		while (*argument != '\0' && ft_isdigit(argument[i]))
			i++;
		if (argument[i] == '\0')
			*valid = 0;
		else
			*valid = 1;
	}
}


#include "./philo.h"

int	check_numerics(int argc, char **argv)
{
	int	valid;

	valid = 0;
	if (argc == 6 || argc == 5)
	{
		check_numeric(&valid, argv[1]);
		check_numeric(&valid, argv[2]);
		check_numeric(&valid, argv[3]);
		check_numeric(&valid, argv[4]);
		if (argc == 6)
		{
			check_numeric(&valid, argv[5]);
		}
	}
	return (valid);
}

int	retreive_input(t_desk *d, int argc, char **argv)
{
	int	check_nums;

	check_nums = check_numerics(argc, argv);
	if ((argc == 6 || argc == 5) && check_nums == 0)
	{
		d->now = current_time_in_milliseconds();
		d->end = 0;
		d->philo_amount = ft_atol(argv[1]);
		d->die_time = ft_atol(argv[2]);
		d->eat_time = ft_atol(argv[3]);
		d->sleep_time = ft_atol(argv[4]);
		if (argc == 6)
			d->meal_amount = ft_atol(argv[5]);
		else
			d->meal_amount = -1;
		return (0);
	}
	else
		return (1);
}


#include "./philo.h"

void	*run_monitor(void *d_point)
{
	t_desk	*d;
	int		i;
	int		all_ate;
	long long	time_since_meal;

	d = (t_desk *)d_point;
	while (1)
	{
		all_ate = 1;
		i = -1;
		while (++i < d->philo_amount)
		{
			pthread_mutex_lock(&d->philos[i].state_mutex);
			time_since_meal = current_time_in_milliseconds() - d->philos[i].had_meal_time;
			if (time_since_meal > d->die_time)
			{
				printf(RED"%lld %d died\n"D, current_time_in_milliseconds() - d->now, d->philos[i].id);
				set_end(d);
				pthread_mutex_unlock(&d->philos[i].state_mutex);
				return (NULL);
			}
			if (d->meal_amount != -1 && d->philos[i].meals < d->meal_amount)
				all_ate = 0;
			pthread_mutex_unlock(&d->philos[i].state_mutex);
		}
		if (d->meal_amount != -1 && all_ate)
		{
			set_end(d);
			break ;
		}
		usleep(1000);
	}
	return (NULL);
}


#include "./philo.h"
//Do not test with more than 200 philosophers.
//Do not test with time_to_die or time_to_eat or time_to_sleep set to values lower than 60 ms.
//Test 1 800 200 200. The philosopher should not eat and should die.
//Test 5 800 200 200. No philosopher should die.
//Test 5 800 200 200 7. No philosopher should die and the simulation should stop when every philosopher has eaten at least 7 times.
//Test 4 410 200 200. No philosopher should die.
//Test 4 310 200 100. One philosopher should die.
//Test with 2 philosophers and check the different times: a death delayed by more than 10 ms is unacceptable.
//Test with any values of your choice to verify all the requirements. Ensure philosophers die at the right time, that they don't steal forks, and so forth.
int	start(t_desk *d)
{
	int	i;

	d->now = current_time_in_milliseconds();
	i = 0;
	while (i < d->philo_amount)
	{
		if (pthread_create(&d->philos[i].thread, NULL, run_philosopher, &d->philos[i]) != 0)
			return (1);
		i++;
	}
	if (pthread_create(&d->monitor, NULL, run_monitor, d) != 0)
		return (1);
	return (0);
}

int	main(int argc, char **argv)
{
	t_desk	d;

	if (retreive_input(&d, argc, argv) == 0)
	{
		if (setup(&d) != 0)
			return (1);
		if (start(&d) != 0)
			return (1);
		end(&d);
	}
	else
	{
		printf("invalid input\n");
		return (1);
	}
	return (0);
}

